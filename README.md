# Техническое Задание: Реализация Фичи OTP-Аутентификации

**Версия документа:** 1.0
**Дата:** 25.05.2024
**Автор:** Senior Product Analyst

---

## Содержание:
1.  [Введение](#1-введение)
    * 1.1. [Цель документа](#11-цель-документа)
    * 1.2. [Область применения](#12-область-применения)
    * 1.3. [Термины и определения](#13-термины-и-определения)
2.  [Общее описание](#2-общее-описание)
    * 2.1. [Назначение фичи](#21-назначение-фичи)
    * 2.2. [Бизнес-цели](#22-бизнес-цели)
    * 2.3. [Обзор архитектуры (на основе MMD)](#23-обзор-архитектуры-на-основе-mmd)
    * 2.4. [Обзор логики состояний (на основе XState)](#24-обзор-логики-состояний-на-основе-xstate)
3.  [Функциональные требования](#3-функциональные-требования)
    * 3.1. [Пользовательские истории (User Stories)](#31-пользовательские-истории-user-stories)
    * 3.2. [Детальное описание состояний и переходов (по XState)](#32-детальное-описание-состояний-и-переходов-по-xstate)
    * 3.3. [Требования к валидации](#33-требования-к-валидации)
4.  [Требования к компонентам системы (на основе MMD)](#4-требования-к-компонентам-системы-на-основе-mmd)
    * 4.1. [AppCore](#41-appcore)
    * 4.2. [AuthFeature](#42-authfeature)
5.  [Требования к данным (Context из XState)](#5-требования-к-данным-context-из-xstate)
6.  [Требования к интеграции](#6-требования-к-интеграции)
    * 6.1. [Сервис отправки OTP (sendOtp)](#61-сервис-отправки-otp-sendotp)
    * 6.2. [Сервис проверки OTP (verifyOtp)](#62-сервис-проверки-otp-verifyotp)
7.  [Нефункциональные требования](#7-нефункциональные-требования)
    * 7.1. [Пользовательский интерфейс (UI/UX)](#71-пользовательский-интерфейс-uiux)
    * 7.2. [Производительность](#72-производительность)
    * 7.3. [Безопасность](#73-безопасность)
    * 7.4. [Обработка ошибок](#74-обработка-ошибок)
    * 7.5. [Логирование](#75-логирование)
8.  [Критерии приемки](#8-критерии-приемки)
9.  [Допущения и ограничения](#9-допущения-и-ограничения)

---

## 1. Введение

### 1.1. Цель документа
Настоящее Техническое Задание (ТЗ) описывает требования к разработке и реализации фичи аутентификации пользователя с использованием одноразового пароля (OTP), отправляемого по SMS, в мобильном приложении.

### 1.2. Область применения
Данное ТЗ предназначено для команды разработки (Flutter-разработчики, Backend-разработчики при необходимости модификации API) и команды QA. Оно охватывает пользовательский интерфейс, бизнес-логику, управление состояниями и взаимодействие компонентов, связанных с OTP-аутентификацией.

### 1.3. Термины и определения
*   **OTP (One-Time Password):** Одноразовый пароль.
*   **MMD (Mermaid Diagram):** Диаграмма, описывающая архитектуру компонентов и их взаимосвязи.
*   **XState:** Библиотека и формализм для создания, интерпретации и визуализации конечных автоматов и диаграмм состояний. В данном ТЗ используется как модель для описания логики BLoC.
*   **BLoC (Business Logic Component):** Паттерн управления состоянием в Flutter.
*   **UI (User Interface):** Пользовательский интерфейс.
*   **UX (User Experience):** Пользовательский опыт.
*   **API (Application Programming Interface):** Интерфейс программирования приложений.

---

## 2. Общее описание

### 2.1. Назначение фичи
Фича OTP-аутентификации предназначена для безопасного входа пользователя в приложение и подтверждения его личности через номер мобильного телефона.

### 2.2. Бизнес-цели
*   Повышение уровня безопасности аккаунтов пользователей.
*   Упрощение процесса входа/регистрации для пользователей (отсутствие необходимости запоминать пароли).
*   Верификация номеров телефонов пользователей.
*   Снижение количества обращений в поддержку по вопросам восстановления пароля.

### 2.3. Обзор архитектуры (на основе MMD)
Система аутентификации будет реализована как отдельный модуль (`AuthFeature`) в Flutter-приложении.
*   **`AppCore`**: Содержит точку входа приложения (`main.dart`) и утилиты, такие как валидаторы (`core/utils/validators.dart`). `main.dart` инициализирует и предоставляет `AuthBloc` и `AuthService`.
*   **`AuthFeature`**:
    *   **`AuthService`**: Сервисный слой для взаимодействия с бэкенд API для отправки и проверки OTP.
    *   **`AuthBloc`**: Управляет состоянием аутентификации, обрабатывает события (`AuthEvent`) и изменяет состояния (`AuthState`). Использует `AuthService` для выполнения асинхронных операций и `Validators` для проверки вводимых данных.
    *   **`AuthWrapperPage`**: Экран-обертка, который слушает изменения состояния `AuthBloc` и отображает соответствующий UI (виджеты) в зависимости от текущего состояния процесса аутентификации.
    *   **`AuthWidgets`**: Набор переиспользуемых виджетов для UI аутентификации:
        *   `PhoneInputWidget`: Для ввода номера телефона.
        *   `OtpInputWidget`: Для ввода OTP-кода.
        *   `AuthenticatedWidget`: Отображается после успешной аутентификации.
        *   `ErrorDisplayWidget`: Для отображения ошибок.
        *   `LoadingIndicatorWidget`: Для индикации загрузки.

### 2.4. Обзор логики состояний (на основе XState)
Логика аутентификации будет управляться конечным автоматом, концептуально описанным в `otp_auth_machine.ts`. Этот автомат определяет следующие состояния и переходы:

*   **Начальное состояние:** `enterPhone` (Ввод номера телефона).
*   **Контекст (данные автомата):**
    *   `phoneNumber`: string (введенный номер телефона)
    *   `otp`: string (введенный OTP-код)
    *   `attempts`: number (количество попыток ввода OTP)
    *   `error`: string (сообщение об ошибке)
*   **Состояния:**
    *   `enterPhone`: Пользователь вводит номер телефона.
    *   `sendingCode`: Запрос на отправку OTP-кода на указанный номер.
    *   `enterOtp`: Пользователь вводит полученный OTP-код.
    *   `verifyingOtp`: Запрос на проверку введенного OTP-кода.
    *   `authenticated`: Пользователь успешно аутентифицирован.
    *   `error`: Произошла ошибка на одном из этапов.

---

## 3. Функциональные требования

### 3.1. Пользовательские истории (User Stories)
*   **US1:** Как пользователь, я хочу иметь возможность ввести свой номер телефона, чтобы получить OTP-код для входа.
*   **US2:** Как пользователь, я хочу видеть индикацию процесса отправки OTP-кода.
*   **US3:** Как пользователь, я хочу получить сообщение об ошибке, если отправка OTP-кода не удалась (например, проблемы с сетью или сервисом).
*   **US4:** Как пользователь, я хочу иметь возможность ввести полученный OTP-код.
*   **US5:** Как пользователь, я хочу видеть индикацию процесса проверки OTP-кода.
*   **US6:** Как пользователь, я хочу быть перенаправленным на главный экран (или в защищенную зону) после успешной верификации OTP.
*   **US7:** Как пользователь, я хочу получить сообщение об ошибке, если введенный OTP-код неверный.
*   **US8:** Как пользователь, я хочу иметь возможность запросить повторную отправку OTP-кода, если я его не получил или если предыдущая попытка отправки была неуспешной.
*   **US9:** Как пользователь, я хочу получить сообщение об ошибке, если я ввел номер телефона или OTP-код в неверном формате.
*   **US10:** Как пользователь, я хочу иметь возможность выйти из системы (logout), что должно вернуть меня на экран ввода номера телефона.

### 3.2. Детальное описание состояний и переходов (по XState)

| Состояние XState | UI Виджет (из `meta.widget` и MMD) | Описание и Действия пользователя                                                                                                                               | События и Переходы (включая условия и действия XState)                                                                                                                                                                                                  |
| :--------------- | :-------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `enterPhone`     | `PhoneInputWidget`                | Пользователю отображается поле для ввода номера телефона и кнопка "Отправить".                                                                                 | **`SUBMIT_PHONE`**: при нажатии кнопки "Отправить".<br/>  - **`cond: isValidPhone`**: переход в `sendingCode`.<br/>  - **`actions: assignPhone, clearError`**. <br/> - Если `!isValidPhone`, остаемся в `enterPhone`, отобразить ошибку валидации (не указано в XState явно, но подразумевается). |
| `sendingCode`    | `LoadingIndicatorWidget`          | Отображается индикатор загрузки. Система инициирует отправку OTP-кода (`invoke: sendOtp`).                                                                    | **`onDone (sendOtp)`**: переход в `enterOtp`.<br/>  - **`actions: clearError`**.<br/>**`onError (sendOtp)`**: переход в `error`.<br/>  - **`actions: setError`**.<br/>**`RESEND_CODE`**: переход в `sendingCode` (повторная отправка).<br/>  - **`actions: clearError`**. |
| `enterOtp`       | `OtpInputWidget`                  | Пользователю отображается поле для ввода OTP-кода и кнопка "Подтвердить". Может быть доступна кнопка "Отправить код повторно".                                 | **`SUBMIT_OTP`**: при нажатии кнопки "Подтвердить".<br/>  - **`cond: isValidOtp`**: переход в `verifyingOtp`.<br/>    - **`actions: assignOtp, clearError`**.<br/>  - Если `!isValidOtp`, переход в `error`.<br/>    - **`actions: assign({ error: 'Неверный формат кода' })`**. |
| `verifyingOtp`   | `LoadingIndicatorWidget`          | Отображается индикатор загрузки. Система инициирует проверку OTP-кода (`invoke: verifyOtp`).                                                                 | **`onDone (verifyOtp)`**: переход в `authenticated`.<br/>  - **`actions: clearError`**.<br/>**`onError (verifyOtp)`**: переход в `error`.<br/>  - **`actions: incrementAttempts, setError`**.                                                                   |
| `authenticated`  | `AuthenticatedWidget` (HomeScreen) | Пользователь успешно аутентифицирован. Отображается контент для аутентифицированных пользователей (например, главный экран) и кнопка "Выйти".              | **`LOGOUT`**: при нажатии кнопки "Выйти".<br/>  - Переход в `enterPhone`.<br/>  - **`actions: clearError`**.                                                                                                                                                   |
| `error`          | `ErrorDisplayWidget`              | Отображается сообщение об ошибке (`context.error`). Предоставляются опции для исправления или повтора действия.                                                  | **`RESEND_CODE`**: переход в `sendingCode`.<br/>  - **`actions: clearError`**.<br/>**`SUBMIT_PHONE`**: (если ошибка возникла на этапе ввода телефона или после неудачной отправки OTP).<br/>  - **`cond: isValidPhone`**: переход в `sendingCode`.<br/>  - **`actions: assignPhone, clearError`**.<br/>**`SUBMIT_OTP`**: (если ошибка возникла на этапе ввода OTP).<br/>  - **`cond: isValidOtp`**: переход в `verifyingOtp`.<br/>  - **`actions: assignOtp, clearError`**.<br/>**`LOGOUT`**: переход в `enterPhone`.<br/> - **`actions: clearError`**. |

### 3.3. Требования к валидации
*   **Валидация номера телефона (`isValidPhone`):**
    *   Должен соответствовать формату E.164 (например, `+79991234567`).
    *   Регулярное выражение: `^\+\d{10,15}$`.
    *   Реализация должна находиться в `core/utils/validators.dart` и использоваться в `AuthBloc` и/или `PhoneInputWidget`.
*   **Валидация OTP-кода (`isValidOtp`):**
    *   Должен состоять из цифр, длина от 4 до 8 символов (уточнить с бэкендом точную длину).
    *   Регулярное выражение: `^\d{4,8}$`.
    *   Реализация должна находиться в `core/utils/validators.dart` и использоваться в `AuthBloc` и/или `OtpInputWidget`.

---

## 4. Требования к компонентам системы (на основе MMD)

### 4.1. AppCore
*   **`main.dart`**:
    *   Инициализирует и предоставляет `AuthBloc` и `AuthService` для всего приложения (или для поддерева виджетов, отвечающего за аутентификацию) с использованием `flutter_bloc` (`BlocProvider`).
    *   Отображает `AuthWrapperPage` как один из корневых виджетов или часть навигационной логики.
*   **`core/utils/validators.dart`**:
    *   Содержит функции валидации:
        *   `bool isValidPhone(String phone)`
        *   `bool isValidOtp(String otp)`
    *   Эти функции должны быть чистыми и легко тестируемыми.

### 4.2. AuthFeature

#### 4.2.1. AuthService
*   **Путь:** `lib/features/auth/services/AuthService.dart`
*   **Ответственность:** Инкапсуляция логики взаимодействия с бэкенд API для OTP-аутентификации.
*   **Методы (контракт):**
    *   `Future<void> sendOtp(String phoneNumber)`: Отправляет запрос на бэкенд для генерации и отправки OTP на указанный `phoneNumber`. Должен выбрасывать исключение в случае ошибки API или сети.
    *   `Future<bool> verifyOtp(String phoneNumber, String otp)`: Отправляет запрос на бэкенд для проверки `otp` для указанного `phoneNumber`. Возвращает `true` при успехе, `false` или выбрасывает исключение при ошибке/неверном коде.
    *   *Примечание: Методы должны быть адаптированы под реальные эндпоинты и контракты бэкенд API. Текущие реализации `sendOtp` и `verifyOtp` в XState являются моками.*

#### 4.2.2. AuthBloc (включая AuthEvent, AuthState)
*   **Путь:** `lib/features/auth/bloc/AuthBloc.dart`, `AuthEvent.dart`, `AuthState.dart`
*   **Ответственность:** Управление состоянием процесса аутентификации, реализация логики, описанной в XState.
*   **`AuthEvent.dart`**: Определяет события, которые могут быть отправлены в `AuthBloc`:
    *   `SubmitPhoneEvent(String phone)`
    *   `SubmitOtpEvent(String otp)`
    *   `ResendCodeEvent()`
    *   `LogoutEvent()`
    *   `InternalCodeSentEvent()` (для перехода после успешной отправки OTP)
    *   `InternalOtpVerifiedEvent()` (для перехода после успешной проверки OTP)
    *   `InternalOtpFailedEvent(String error)` (для перехода при ошибке)
*   **`AuthState.dart`**: Определяет состояния `AuthBloc`, соответствующие состояниям XState, и хранит необходимые данные:
    *   `AuthInitial` (соответствует `enterPhone` в XState)
    *   `AuthCodeSending` (соответствует `sendingCode`)
    *   `AuthOtpInput(String phoneNumber)` (соответствует `enterOtp`, хранит номер для повторной отправки)
    *   `AuthOtpVerifying(String phoneNumber, String otp)` (соответствует `verifyingOtp`)
    *   `AuthAuthenticated` (соответствует `authenticated`)
    *   `AuthError(String message, {bool canResend, bool canRetryPhone, bool canRetryOtp})` (соответствует `error`, хранит сообщение и флаги доступных действий)
    *   Каждое состояние должно содержать данные из `AuthContext` XState, если они релевантны для UI (например, `phoneNumber`, `error`).
*   **`AuthBloc.dart`**:
    *   Использует `AuthService` для выполнения асинхронных операций.
    *   Использует `Validators` для проверки данных перед отправкой запросов.
    *   Обрабатывает `AuthEvent` и эмитит новые `AuthState`.
    *   Логика переходов и действий должна строго соответствовать XState-машине.
    *   Управляет счетчиком попыток `attempts` и сообщением об ошибке `error` (в соответствии с `AuthContext` из XState).

#### 4.2.3. AuthWrapperPage
*   **Путь:** `lib/features/auth/screens/AuthWrapperPage.dart`
*   **Ответственность:** Основной экран фичи аутентификации.
    *   Подписывается на состояния `AuthBloc` через `BlocBuilder` или `BlocListener`.
    *   В зависимости от текущего `AuthState`, отображает один из следующих виджетов:
        *   `PhoneInputWidget` (для `AuthInitial`)
        *   `LoadingIndicatorWidget` (для `AuthCodeSending`, `AuthOtpVerifying`)
        *   `OtpInputWidget` (для `AuthOtpInput`)
        *   `AuthenticatedWidget` (для `AuthAuthenticated`)
        *   `ErrorDisplayWidget` (для `AuthError`)

#### 4.2.4. AuthWidgets
*   **Путь:** `lib/features/auth/widgets/*`
*   **Ответственность:** Предоставление UI-компонентов для процесса аутентификации.
*   **`PhoneInputWidget`**:
    *   Содержит `TextField` для ввода номера телефона и кнопку "Отправить".
    *   Использует `Validators.isValidPhone` для локальной валидации (опционально, основная валидация в BLoC).
    *   При нажатии на кнопку отправляет `SubmitPhoneEvent` в `AuthBloc`.
*   **`OtpInputWidget`**:
    *   Содержит `TextField` (или набор полей) для ввода OTP и кнопку "Подтвердить".
    *   Может содержать кнопку/ссылку "Отправить код повторно", которая отправляет `ResendCodeEvent` в `AuthBloc`.
    *   Использует `Validators.isValidOtp` для локальной валидации (опционально).
    *   При нажатии на кнопку "Подтвердить" отправляет `SubmitOtpEvent` в `AuthBloc`.
*   **`AuthenticatedWidget`**:
    *   Отображает контент для аутентифицированного пользователя (например, приветствие и кнопку "Выйти").
    *   Кнопка "Выйти" отправляет `LogoutEvent` в `AuthBloc`.
*   **`ErrorDisplayWidget`**:
    *   Отображает сообщение об ошибке из `AuthState.AuthError`.
    *   Может содержать кнопки для повторных действий (например, "Повторить отправку кода", "Ввести номер заново", "Ввести OTP заново"), которые отправляют соответствующие события в `AuthBloc`.
*   **`LoadingIndicatorWidget`**:
    *   Простой виджет для отображения индикатора прогресса (например, `CircularProgressIndicator`).

---

## 5. Требования к данным (Context из XState)
Состояние `AuthBloc` должно управлять следующими данными, аналогично `AuthContext` из XState:
*   `phoneNumber: String`: Текущий введенный номер телефона.
*   `otp: String`: Текущий введенный OTP-код.
*   `attempts: int`: Количество неудачных попыток верификации OTP. Может использоваться для логики блокировки или отображения предупреждений.
*   `error: String?`: Текст последней ошибки. Должен быть `null`, если ошибки нет.

Эти данные должны сохраняться при переходах между состояниями, где это логично (например, `phoneNumber` должен быть доступен в состоянии `enterOtp` для возможности повторной отправки).

---

## 6. Требования к интеграции

### 6.1. Сервис отправки OTP (`sendOtp` из XState, реализуется в `AuthService`)
*   **Вход:** `phoneNumber: String`
*   **Выход (успех):** Успешная отправка OTP (никаких данных не возвращается, `void`).
*   **Выход (ошибка):** Исключение с описанием ошибки (например, `NetworkError`, `SmsGatewayError`, `InvalidPhoneNumberError` от бэкенда).
*   **Реализация:** Должен быть реализован реальный API-вызов к бэкенд-сервису, отвечающему за отправку SMS.
*   **Требования к API:** Бэкенд API должен принимать номер телефона и инициировать отправку OTP. Должен возвращать соответствующие коды ошибок.

### 6.2. Сервис проверки OTP (`verifyOtp` из XState, реализуется в `AuthService`)
*   **Вход:** `phoneNumber: String`, `otp: String`
*   **Выход (успех):** `true` (OTP верен).
*   **Выход (ошибка):** `false` или исключение с описанием ошибки (например, `InvalidOtpError`, `OtpExpiredError`, `TooManyAttemptsError`, `NetworkError`).
*   **Реализация:** Должен быть реализован реальный API-вызов к бэкенд-сервису для проверки OTP.
*   **Требования к API:** Бэкенд API должен принимать номер телефона и OTP, выполнять проверку и возвращать результат (успех/неудача) и коды ошибок.

---

## 7. Нефункциональные требования

### 7.1. Пользовательский интерфейс (UI/UX)
*   Интерфейс должен быть интуитивно понятным и отзывчивым.
*   Все интерактивные элементы должны иметь четкую обратную связь (нажатия, состояния загрузки).
*   Сообщения об ошибках должны быть ясными и предоставлять пользователю информацию о дальнейших действиях.
*   Дизайн должен соответствовать общему гайдлайну приложения.

### 7.2. Производительность
*   Время отклика UI на действия пользователя не должно превышать 200 мс.
*   Время ожидания ответа от API (отправка/проверка OTP) должно сопровождаться индикатором загрузки. Максимальное время ожидания перед таймаутом (если не определено API) - 30 секунд.
*   OTP-код должен доставляться пользователю в течение 5-30 секунд (зависит от SMS-шлюза).

### 7.3. Безопасность
*   OTP-коды должны генерироваться на стороне бэкенда и быть криптографически стойкими.
*   Передача OTP-кодов и номера телефона между клиентом и сервером должна осуществляться по защищенному каналу (HTTPS).
*   Необходимо предусмотреть защиту от brute-force атак на проверку OTP (например, ограничение количества попыток, CAPTCHA после нескольких неудач – реализуется на бэкенде, клиент должен корректно обрабатывать соответствующие ошибки API).
*   OTP-коды должны иметь короткий срок действия (например, 2-5 минут).

### 7.4. Обработка ошибок
*   Приложение должно корректно обрабатывать ошибки сети и API, отображая пользователю понятные сообщения.
*   Предоставлять возможность повторить действие при временных сбоях (например, "Повторить отправку кода").
*   XState `error` состояние должно четко отображать причину проблемы и возможные пути решения.

### 7.5. Логирование
*   Ключевые события процесса аутентификации (начало ввода номера, запрос OTP, ответ от сервиса OTP, результат проверки OTP, ошибки) должны логироваться для целей отладки и мониторинга.
*   Логи не должны содержать чувствительные данные в открытом виде (например, сам OTP-код).

---

## 8. Критерии приемки
*   **CP1:** Пользователь может успешно войти в приложение, введя корректный номер телефона и полученный OTP-код.
*   **CP2:** При вводе невалидного номера телефона (формат) отображается ошибка валидации, запрос на сервер не уходит.
*   **CP3:** При вводе невалидного OTP-кода (формат) отображается ошибка валидации, запрос на сервер не уходит.
*   **CP4:** При ошибке отправки OTP (например, SMS-сервис недоступен) отображается соответствующее сообщение и возможность повторной отправки.
*   **CP5:** При вводе неверного OTP-кода отображается ошибка "Неверный код", увеличивается счетчик `attempts`.
*   **CP6:** Кнопка "Отправить код повторно" активна и функциональна в состояниях `enterOtp` и `error` (если применимо).
*   **CP7:** После успешной аутентификации пользователь видит `AuthenticatedWidget` (или соответствующий экран приложения).
*   **CP8:** Функция выхода из системы (`LOGOUT`) возвращает пользователя на экран ввода номера телефона (`enterPhone`).
*   **CP9:** Индикаторы загрузки (`LoadingIndicatorWidget`) отображаются во время выполнения запросов `sendOtp` и `verifyOtp`.
*   **CP10:** Все переходы между состояниями соответствуют логике, описанной в XState.
*   **CP11:** Валидаторы из `core/utils/validators.dart` корректно используются и отрабатывают.
*   **CP12:** `AuthService` корректно взаимодействует с (замоканными или реальными) API бэкенда.

---

## 9. Допущения и ограничения
*   **Допущение 1:** Бэкенд API для отправки и проверки OTP существует или будет разработан параллельно согласно требованиям, описанным в разделе 6.
*   **Допущение 2:** Дизайн UI-компонентов (`AuthWidgets`) будет предоставлен или разработан на основе существующих гайдлайнов приложения.
*   **Допущение 3:** Логика XState, предоставленная в `otp_auth_machine.ts`, является актуальной и полной моделью для реализации в `AuthBloc`.
*   **Ограничение 1:** Текущие реализации сервисов `sendOtp` и `verifyOtp` в XState являются моками и должны быть заменены реальными вызовами к API через `AuthService`.
*   **Ограничение 2:** Механизмы защиты от SMS-флуда и сложные сценарии блокировки аккаунта (кроме инкремента `attempts`) выходят за рамки данного ТЗ для клиентской части, предполагается их реализация на стороне бэкенда. Клиент должен уметь обрабатывать соответствующие коды ошибок от API.
